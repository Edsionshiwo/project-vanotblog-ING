/*
 Navicat Premium Data Transfer

 Source Server         : localhost
 Source Server Type    : MySQL
 Source Server Version : 80013
 Source Host           : localhost:3306
 Source Schema         : vanotblog

 Target Server Type    : MySQL
 Target Server Version : 80013
 File Encoding         : 65001

 Date: 29/07/2021 11:36:37
*/

SET NAMES utf8mb4;
SET FOREIGN_KEY_CHECKS = 0;

-- ----------------------------
-- Table structure for m_blog
-- ----------------------------
DROP TABLE IF EXISTS `m_blog`;
CREATE TABLE `m_blog`  (
  `id` bigint(20) NOT NULL AUTO_INCREMENT,
  `user_id` bigint(20) NOT NULL,
  `title` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NOT NULL,
  `description` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NOT NULL,
  `content` longtext CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NULL,
  `created` datetime NOT NULL ON UPDATE CURRENT_TIMESTAMP,
  `status` tinyint(4) NULL DEFAULT NULL,
  PRIMARY KEY (`id`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 27 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_0900_ai_ci ROW_FORMAT = Dynamic;

-- ----------------------------
-- Records of m_blog
-- ----------------------------
INSERT INTO `m_blog` VALUES (21, 3, 'wertrt', 'sdfdsfsdf', 'dfaergerag', '2021-07-25 20:40:30', 0);
INSERT INTO `m_blog` VALUES (22, 3, '博客文章测试', '是老大看风景卢卡斯的积分送爱的感觉案例，十大发射点，发生的。上的飞机拉萨的。', '## Core Framework 简介\n\nCore Framework 是一个基于 Unity 引擎的为我自己开发的游戏 Core：核 提供的框架支持的一套代码，主要对游戏开发过程中常用模块进行了封装，可以比较好地规范地解决一些复用性强的代码逻辑、加快开发速度并保证开发质量。\n\n在 Core Framework 版本中，包含以下 10 个模块。\n\n1. **状态机 (StateMachine)** - 提供创建和使用有限状态机的功能，游戏底层的有限状态机，为游戏中几乎所有实体类以及游戏控制器提供逻辑处理支持。\n2. **动画控制器 (Animator Controller)** - 在 Unity 3D 原有动画控制器的基础上进行封装，实现一些定制化的动画方案。\n3. **音效控制器 (Audio Manager)** - 在 Unity 3D 原有音效控制器的基础上进行封装，实现一些定制化的音效方案。\n4. **相机控制器 (Camera Controller)** - 为游戏中主角的视角变换提供更加顺滑与正常逻辑的体验，编写了两个具体相机控制类来实现。\n5. **物理组件 (Physics Controller)** - 给主角提供了复杂的物理计算逻辑来使游戏的操作手感变得更好，以及提供了多个可供调整的参数来灵活地调整主角的物理特性。以及提供了检测点的服务来处理主角与场景中其他实例交互的特殊逻辑。\n6. **任务组件 (Timer Manager)** - 将游戏中要被异步调用的函数定义为任务集中在任务管理器中处理，可以灵活生成两种任务来处理不同的业务需要。\n7. **游戏单元 (Entity)** - 游戏中大多数舞台上的实例的基类，带有基本的状态机、动画组件。\n8. **效果（影响）模块 (Effective)** - 定义了一个影响域，来让带有影响域的实例可以影响在其影响域内部的实例的状态或行为。\n9. **装备模块 (Equipment)** - 顾名思义，为游戏中的生物提供装备的功能接口，其中装备控制器用于管理实例身上的装备接口情况。装备依附于某个生物身上，其可以响应键盘或是鼠标输入事件，并根据自身状态机做出某些逻辑处理其宿主或是自身的状态或行为。\n10. **对话组件 (Dialog System)** - 将游戏中的对话模块集中抽离成此模块，以便于游戏中的快速开发，其本身属于一个影响模块。在其影响域内角色可以出发对话事件。', '2021-07-26 22:04:31', 0);
INSERT INTO `m_blog` VALUES (23, 3, '撒旦飞洒地方士大夫撒旦', '上的发生的发士大夫十大发士大夫上的发生的发士大夫十大发士大夫上的发生的发士大夫十大发士大夫上的发生的发士大夫十大发士大夫上的发生的发士大夫十大发士大夫上的发生的发士大夫十大发士大夫上的发生的发士大夫十大发士大夫上的发生的发士大夫十大发士大夫上的发生的发士大夫十大发士大夫上的发生的发士大夫十大发士大夫上的发生的发士大夫十大发士大夫上的发生的发士大夫十大发士大夫上的发生的发士大夫十大发士大夫', '## Core Framework 简介\n\nCore Framework 是一个基于 Unity 引擎的为我自己开发的游戏 Core：核 提供的框架支持的一套代码，主要对游戏开发过程中常用模块进行了封装，可以比较好地规范地解决一些复用性强的代码逻辑、加快开发速度并保证开发质量。\n\n在 Core Framework 版本中，包含以下 10 个模块。\n\n1. **状态机 (StateMachine)** - 提供创建和使用有限状态机的功能，游戏底层的有限状态机，为游戏中几乎所有实体类以及游戏控制器提供逻辑处理支持。\n2. **动画控制器 (Animator Controller)** - 在 Unity 3D 原有动画控制器的基础上进行封装，实现一些定制化的动画方案。\n3. **音效控制器 (Audio Manager)** - 在 Unity 3D 原有音效控制器的基础上进行封装，实现一些定制化的音效方案。\n4. **相机控制器 (Camera Controller)** - 为游戏中主角的视角变换提供更加顺滑与正常逻辑的体验，编写了两个具体相机控制类来实现。\n5. **物理组件 (Physics Controller)** - 给主角提供了复杂的物理计算逻辑来使游戏的操作手感变得更好，以及提供了多个可供调整的参数来灵活地调整主角的物理特性。以及提供了检测点的服务来处理主角与场景中其他实例交互的特殊逻辑。\n6. **任务组件 (Timer Manager)** - 将游戏中要被异步调用的函数定义为任务集中在任务管理器中处理，可以灵活生成两种任务来处理不同的业务需要。\n7. **游戏单元 (Entity)** - 游戏中大多数舞台上的实例的基类，带有基本的状态机、动画组件。\n8. **效果（影响）模块 (Effective)** - 定义了一个影响域，来让带有影响域的实例可以影响在其影响域内部的实例的状态或行为。\n9. **装备模块 (Equipment)** - 顾名思义，为游戏中的生物提供装备的功能接口，其中装备控制器用于管理实例身上的装备接口情况。装备依附于某个生物身上，其可以响应键盘或是鼠标输入事件，并根据自身状态机做出某些逻辑处理其宿主或是自身的状态或行为。\n10. **对话组件 (Dialog System)** - 将游戏中的对话模块集中抽离成此模块，以便于游戏中的快速开发，其本身属于一个影响模块。在其影响域内角色可以出发对话事件。', '2021-07-26 22:11:31', 0);
INSERT INTO `m_blog` VALUES (24, 3, '的撒发射点发射点士大夫士大夫s', 's士大夫士大夫阿斯顿发射点s士大夫士大夫阿斯顿发射点s士大夫士大夫阿斯顿发射点', '## Core Framework 简介\n\nCore Framework 是一个基于 Unity 引擎的为我自己开发的游戏 Core：核 提供的框架支持的一套代码，主要对游戏开发过程中常用模块进行了封装，可以比较好地规范地解决一些复用性强的代码逻辑、加快开发速度并保证开发质量。\n\n在 Core Framework 版本中，包含以下 10 个模块。\n\n1. **状态机 (StateMachine)** - 提供创建和使用有限状态机的功能，游戏底层的有限状态机，为游戏中几乎所有实体类以及游戏控制器提供逻辑处理支持。\n2. **动画控制器 (Animator Controller)** - 在 Unity 3D 原有动画控制器的基础上进行封装，实现一些定制化的动画方案。\n3. **音效控制器 (Audio Manager)** - 在 Unity 3D 原有音效控制器的基础上进行封装，实现一些定制化的音效方案。\n4. **相机控制器 (Camera Controller)** - 为游戏中主角的视角变换提供更加顺滑与正常逻辑的体验，编写了两个具体相机控制类来实现。\n5. **物理组件 (Physics Controller)** - 给主角提供了复杂的物理计算逻辑来使游戏的操作手感变得更好，以及提供了多个可供调整的参数来灵活地调整主角的物理特性。以及提供了检测点的服务来处理主角与场景中其他实例交互的特殊逻辑。\n6. **任务组件 (Timer Manager)** - 将游戏中要被异步调用的函数定义为任务集中在任务管理器中处理，可以灵活生成两种任务来处理不同的业务需要。\n7. **游戏单元 (Entity)** - 游戏中大多数舞台上的实例的基类，带有基本的状态机、动画组件。\n8. **效果（影响）模块 (Effective)** - 定义了一个影响域，来让带有影响域的实例可以影响在其影响域内部的实例的状态或行为。\n9. **装备模块 (Equipment)** - 顾名思义，为游戏中的生物提供装备的功能接口，其中装备控制器用于管理实例身上的装备接口情况。装备依附于某个生物身上，其可以响应键盘或是鼠标输入事件，并根据自身状态机做出某些逻辑处理其宿主或是自身的状态或行为。\n10. **对话组件 (Dialog System)** - 将游戏中的对话模块集中抽离成此模块，以便于游戏中的快速开发，其本身属于一个影响模块。在其影响域内角色可以出发对话事件。', '2021-07-26 22:11:52', 0);
INSERT INTO `m_blog` VALUES (25, 3, 'ask地方就是滴哦放假啊是滴哦福斯随地可见发', '是滴哦飞机阿瑟东i附近啊是滴哦佩服啊是', '接口信息\n-------------\n\n## `/user` 用户接口\n\n### `路由`  `请求方法` `权限` 简述\n\n### `/login`  `GET` `POST` `USER`  登录\n\n* GET     \n  返回 测试页面（不准确） 在生产环境中被弃用\n\n* POST  \n  获取 \n\n  + 用户名 username  \n  + 密码 password   \n\n  返回 登录信息\n\n### `/logout`  `GET` 登出当前用户\n\n* GET     \n  返回 登出消息\n\n\n### `/detail`  `GET` 获取当前用户详细信息\n\n* GET     \n  返回 当前用户信息 UserInfo\n\n\n### `/register`  `GET` `POST` 注册用户\n\n* GET     \n  返回 测试页面（不准确） 在生产环境中被弃用\n\n* POST  \n  获取  \n\n  + 用户名 username \n  + 密码 password \n  + 邮箱 email\n  + 手机号码 mobile  \n  + 地址 location\n  + 出生日期 birth \n\n  返回 用户信息 UserInfo\n\n\n### `/update`  `GET` `POST` 更新当前用户详细信息\n\n* GET     \n  返回 测试页面（不准确） 在生产环境中被弃用\n\n* POST  \n  获取  \n\n  + 邮箱 email\n  + 手机号码 mobile  \n  + 地址 location\n  + 出生日期 birth \n  + 描述 description\n\n  返回 用户信息 UserInfo  \n\n* 注 这里的获取内容可以缺省\n\n\n### `/new_cost`  `GET` `POST` 用户新建 COST 工单\n\n* GET     \n  返回 测试页面（不准确） 在生产环境中被弃用\n\n* POST  \n  获取  \n\n  + 工单描述 remarks\n  + 专家ID expert_id （可不做）\n\n  返回 工单信息 WorkOrder  \n\n\n### `/new_earning`  `GET` `POST` 用户新建 EARNING 工单\n\n* GET     \n  返回 测试页面（不准确） 在生产环境中被弃用\n\n* POST  \n  获取  \n\n  + 工单描述 remarks\n  + 专家ID expert_id （可不做）\n\n  返回 工单信息 WorkOrder  \n\n\n### `/new_comprehensive`  `GET` `POST` 用户新建 COMPREHENSIVE 工单\n\n* GET     \n  返回 测试页面（不准确） 在生产环境中被弃用\n\n* POST  \n  获取  \n\n  + 工单描述 remarks\n  + 专家ID expert_id （可不做）\n  + 上传（单个）数据集 csv文件 file\n\n  返回 工单信息 WorkOrder  \n\n\n### `/new_market`  `GET` `POST` 用户新建 MARKET 工单\n\n* GET     \n  返回 测试页面（不准确） 在生产环境中被弃用\n\n* POST  \n  获取  \n\n  + 工单描述 remarks\n  + 专家ID expert_id （可不做）\n  + 上传（单个）数据集 csv文件 file\n\n  返回 工单信息 WorkOrder  \n\n\n### `/all_work_order`  `GET`  查询所用户的所有工单\n\n* GET     \n  返回 当前用户持有的所有工单 WorkOrder[]\n\n\n### `/detail_work_order`  `GET` `POST` 查询工单详情\n\n* GET     \n  返回 测试页面（不准确） 在生产环境中被弃用\n\n* POST  \n  获取  \n\n  + 工单id order_id\n\n  返回 工单信息 WorkOrder 与 具体工单信息 CostValuation/EarningValuation/ComprehensiveValuation  \n\n\n### `/get_work_order`  `GET` `POST` 带参数筛选工单（）\n\n* GET     \n  返回 测试页面（不准确） 在生产环境中被弃用\n\n* POST  \n  获取  \n\n  + 工单id order_id\n  + 工单状态 status\n  + 分页当前页 page\n  + 分页每页页数 per_page\n\n  返回 工单信息 WorkOrder（带分页）\n\n\n### `/get_log`  `GET` `POST` 带参数筛选工单（）\n\n* GET     \n  返回 与用户有关的日志信息 Log（带分页）\n\n\n### `/apply_expert`  `GET` `POST` 申请专家权限\n\n* GET     \n  返回 测试页面（不准确） 在生产环境中被弃用\n\n* POST  \n  获取  \n\n  + 真实姓名 realname\n  + 头衔 job_title\n  + 自我介绍 introduction\n\n  返回 申请信息 ExpertApply\n\n\n## `/expert` 专家接口\n\n### `/login`  `GET` `POST` `USER`  登录\n\n* GET     \n  返回 测试页面（不准确） 在生产环境中被弃用\n\n* POST  \n  获取 用户名 username 密码 password   \n  返回 登录信息\n\n\n### `/logout`  `GET` 登出当前用户\n\n* GET     \n  返回 登出消息\n\n\n### `/detail`  `GET` 获取当前专家详细信息\n\n* GET     \n  返回 当前专家信息 ExpertInfo\n\n\n### `/update`  `GET` `POST` 更新当前用户详细信息\n\n* GET     \n  返回 测试页面（不准确） 在生产环境中被弃用\n\n* POST  \n  获取  \n\n  + 邮箱 email\n  + 手机号码 mobile  \n  + 地址 location\n  + 出生日期 birth \n  + 描述 description\n\n  返回 专家信息 ExpertInfo  \n\n* 注 这里的获取内容可以缺省\n\n\n### `/all_wait_work_order`  `GET`  查看所有待评估的工单\n\n* GET     \n  返回 所有待评估的工单 WorkOrder[]（带分页）\n\n\n### `/all_self_work_order`  `GET`  查看所有自己负责的工单\n\n* GET     \n  返回 所有自己负责的工单 WorkOrder[]（带分页）\n\n\n### `/detail_work_order`  `GET` `POST` 查询工单详情\n\n* GET     \n  返回 测试页面（不准确） 在生产环境中被弃用\n\n* POST  \n  获取  \n\n  + 工单id order_id\n\n  返回 工单信息 WorkOrder 与 具体工单信息 CostValuation/EarningValuation/ComprehensiveValuation  \n\n\n### `/download_order_file`  `GET` `POST` 获取某工单附件\n\n* GET     \n  返回 测试页面（不准确） 在生产环境中被弃用\n\n* POST  \n  获取  \n\n  + 工单id order_id\n\n  返回 工单附件 file  \n\n\n### `/process_comprehensive`  `GET` `POST` 评估 COMPREHENSIVE 工单\n\n* GET     \n  返回 测试页面（不准确） 在生产环境中被弃用\n\n* POST  \n  获取  \n\n  + 工单id order_id\n  + rareness\n  + timeliness  \n  + dimensional\n  + economy \n  + 质量权重 数组 quality_weight\n  + 应用权重 数组 applied_weight\n\n  返回 COMPREHENSIVE 工单信息 ComprehensivetValuation  \n\n### `/process_cost`  `GET` `POST` 评估 COST 工单\n\n* GET     \n  返回 测试页面（不准确） 在生产环境中被弃用\n\n* POST  \n  获取  \n\n  + 工单id order_id\n  + R\n  + C  \n  + II\n  + M \n  + E\n\n  返回 COST 工单信息 CostValuation  \n\n### `/process_earning`  `GET` `POST` 评估 EARNING 工单\n\n* GET     \n  返回 测试页面（不准确） 在生产环境中被弃用\n\n* POST  \n  获取  \n\n  + 工单id order_id\n  + n\n  + r  \n  + 数组 R\n\n  返回 EARNING 工单信息 EarningValuation  \n\n\n\n## `/admin` 管理员接口\n\n### `/login`  `GET` `POST` `USER`  登录\n\n* GET     \n  返回 测试页面（不准确） 在生产环境中被弃用\n\n* POST  \n  获取 用户名 username 密码 password   \n  返回 登录信息 Login\n\n\n### `/logout`  `GET` 登出当前用户\n\n* GET     \n  返回 登出消息\n\n\n### `/detail`  `GET` 获取当前管理员详细信息\n\n* GET     \n  返回 当前管理员信息 AdminInfo\n\n\n### `/update`  `GET` `POST` 更新当前管理员详细信息\n\n* GET     \n  返回 测试页面（不准确） 在生产环境中被弃用\n\n* POST  \n  获取  \n\n  + 邮箱 email\n  + 手机号码 mobile  \n  + 地址 location\n  + 出生日期 birth \n  + 描述 description\n\n  返回 管理员信息 AdminInfo\n\n* 注 这里的获取内容可以缺省\n\n\n### `/get_user_info`  `GET` `POST` 查询用户信息\n\n* GET     \n  返回 所有用户信息 UserInfo[]\n\n* POST  \n  获取  \n\n  + 用户id id\n  + 用户名 username  \n  + 邮箱 email\n  + 地址 location\n  + 分页当前页 page\n  + 分页每页页数 per_page\n\n  返回 用户信息 UserInfo[]（带分页）\n\n* 注 这里的获取内容可以缺省\n\n\n### `/update_user_info`  `POST` 更新某用户信息\n\n* POST  \n  获取  \n\n  + 用户id id\n  + 邮箱 email\n  + 手机号码 mobile  \n  + 地址 location\n  + 出生日期 birth \n  + 描述 description\n\n  返回 用户信息 UserInfo\n\n* 注 这里的获取内容可以缺省\n\n\n### `/get_work_order`  `GET` `POST` 查询工单信息\n\n* GET     \n  返回 所有工单信息 WorkOrder[]\n\n* POST  \n  获取  \n\n  + 工单id order_id\n  + 分页当前页 page\n  + 分页每页页数 per_page\n\n  返回 工单信息 WorkOrder[]（带分页）\n\n* 注 这里的获取内容可以缺省\n\n\n### `/detail_work_order`  `GET` `POST` 查询工单详情\n\n* GET     \n  返回 测试页面（不准确） 在生产环境中被弃用\n\n* POST  \n  获取  \n\n  + 工单id order_id\n\n  返回 工单信息 WorkOrder 与 具体工单信息 CostValuation/EarningValuation/ComprehensiveValuation  \n\n\n### `/get_login_log`  `GET` `POST` 查询登录日志信息\n\n* GET     \n  返回 所有登录日志信息 LoginLog[]\n\n* POST  \n  获取  \n\n  + 用户名 username\n  + 分页当前页 page\n  + 分页每页页数 per_page\n\n  返回 登录日志信息 LoginLog[]（带分页）\n\n* 注 这里的获取内容可以缺省\n\n\n### `/get_log`  `GET` `POST` 查询日志信息\n\n* GET     \n  返回 所有工单信息 Log[]\n\n* POST  \n  获取  \n\n  + 用户名 username\n  + 分页当前页 page\n  + 分页每页页数 per_page\n\n  返回 日志信息 Log[]（带分页）\n\n* 注 这里的获取内容可以缺省\n\n    \n\n### `/get_expert_apply`  `GET` `POST` 查询专家申请表单\n\n* GET     \n  返回 测试页面（不准确） 在生产环境中被弃用\n\n* POST  \n  获取  \n\n  + 分页当前页 page\n  + 分页每页页数 per_page    \n\n  返回 专家申请信息 ExpertApply[]（带分页）\n\n* 注 这里的获取内容可以缺省\n\n\n### `/update_expert_apply`  `GET` `POST` 审批专家申请表单\n\n* GET     \n  返回 测试页面（不准确） 在生产环境中被弃用\n\n* POST  \n  获取  \n\n  + 专家ID apply_id\n  + 审批结果 status（参阅宏变量）\n\n  返回 专家申请信息 ExpertApply\n\n------------------\n\n## 涉及的宏变量\n\n### 工单类别\n\n```\n# 成本法\nCOST = 1\n# 收益法\nEARNING = 2\n# 综合估值法\nCOMPREHENSIVE = 3\n# 市场法\nMARKET = 4\n```\n\n### 工单状态\n\n```\n# 等待\nORDER_WAIT = 0  \n# 完成\nORDER_DONE = 1  \n# 接受\nORDER_RECE = 2  \n# 冻结\nORDER_FREEZE = 3  \n```\n\n### 人员权限\n\n```\nSUPER_ADMIN = 1\nADMIN = 2\nEXPERT = 3\nUSER = 4\n```\n\n### 专家审批状态\n\n```\n# 等待\nWAIT = 0\n# 通过\nPASS = 1\n# 拒绝\nDENY = 2\n```', '2021-07-27 11:25:57', 0);
INSERT INTO `m_blog` VALUES (26, 3, 'jhsdfkjsdfkljslkkljsfldkj', 'kljds;lfkjasdpofujsadoifjsadoifjhsadoifj', 'Design Document for Project 2: Threads\n======================================\n\n## <font color=\'lightgreen\'>Group Members</font>\n\n* 蒋 贤伟                                               \n\n## <font color=\'lightblue\'>文档简介</font>\n\n>该文档主要论述pintos-Project 2:Thread部分27个测试点的通过（Pass）的实现方法与思路。  \n>其中源代码的编写参考了博客：https://www.cnblogs.com/laiy/p/pintos_project1_thread.html 的内容。  \n>源代码的每个逻辑与涉及到的底层函数都做了详细的备注与解释。  \n>接下来分三个部分（也就是project中的三个部分）来展开报告。\n\n\n## <font color=\'lightblue\'>第一部分</font>\n\n### <font color=\'orange\' face=\"consolas\">alarm-single\\multiple\\simultaneous\\zero\\negative</font>\n\n>修改timer_sleep(int64_t ticks)函数的忙等机制，更改为阻塞唤醒的机制，来避免进程在就绪队列与运行状态反复切换。\n\n**思路&Rational**  \n\n我们需要修改原代码中的 ```timer_sleep()``` 函数，让线程能够以更有效的方式在规定的一段时间内处于 ```sleep``` 状态（也就是终止运行）的状态。  \n原代码中提供的基础实现：反复确认进程是否处于运行态，若是则将其置为就绪态，直至时间片耗尽。\n那么我们可以很清晰地得到一个改进的思路：\n\n1. 给 ```thread``` 新增一个用于记录剩余阻塞时间的变量 ```ticks_blocked```，首先给目标线程设置预定的阻塞时间并使其进入 ```THREAD_BLOCK``` 阻塞状态。\n2. 持续更新剩余时间，直至剩余阻塞时间归零，再解除目标线程的阻塞状态。\n\n那么更改算法的思路已经结束了，但是我们需要考虑一些因为算法改变所需要额外做的辅助工作。\n\n3. 因为额外的记录剩余时间的变量的引入，我们需要持续地更新这一变量，而且是对所有线程做这一操作。\n\n**数据结构**\n\n```C\nstruct thread\n{\n    ...\n    // 增加变量用于记录剩余阻塞时间\n   int64_t ticks_blocked; \n    ...\n}\n```\n\n**算法&实现**\n\n修改 `timer_sleep()` ，实现1中的改进算法。\n\n```C\nvoid timer_sleep(int64_t ticks)\n{\n  if (ticks <= 0){\n    return;\n  }\n  // 设置可以被打断，避免死循环\n  ASSERT(intr_get_level() == INTR_ON);\n\n  // 不可被中断的包裹\n  enum intr_level old_level = intr_disable();\n  \n  // 返回当前线程起始指针位置，也就是指向当前线程的指针\n  struct thread *current_thread = thread_current();\n  current_thread->ticks_blocked = ticks;\n  \n  // 阻塞当前线程\n  thread_block();\n\n  intr_set_level(old_level);\n}\n```\n\n在经过底层部分源码的阅读后（在源代码中有详细备注，这里不展开论述）。这里值得一提地是，下面这一种包裹的结构可以保证其中间的代码执行不被打断，以避免不必要的错误出现，在后续的代码中相当常见。\n\n```C\n    enum intr_level old_level = intr_disable();\n    ...\n    intr_set_level(old_level);\n```\n\n每次时间片轮转结束都会调用 `timer_interrupt()` 函数，可以用于我们持续地为所有进程更新`ticks_blocked`。\n`thread_foreach(func, aux)`函数为我们提供了遍历所有线程并执行某一函数的功能，同样可以协助我们实现目标2、3。\n\n```C\nstatic void timer_interrupt(struct intr_frame *args UNUSED)\n{\n    ...\n    // 对每个线程执行blocked_thread_check函数，为阻塞队列中线程处理阻塞时钟\n    thread_foreach(blocked_thread_check, NULL);\n    ...\n}\n```\n\n`blocked_thread_check()` 函数来做具体的阻塞时钟操作，与线程阻塞状态判定\n\n```C\nvoid blocked_thread_check(struct thread *t, void *aux UNUSED)\n{\n  if (t->status == THREAD_BLOCKED && t->ticks_blocked > 0)\n  {\n    // 阻塞时钟自减\n    t->ticks_blocked--;\n    // 如果阻塞时钟归零\n    if (t->ticks_blocked == 0)\n    {\n      // 将线程从阻塞队列挪到就绪队列\n      thread_unblock(t);\n    }\n  }\n}\n```\n\n### <font color=\'orange\' face=\"consolas\">alarm-priority</font>\n\n>在将线程放入就绪队列后，对队列进行指定优先级规则的排序，来确保就绪队列内线程优先级的正确。\n\n**思路&Rational**  \n\n其实这件事情很简单，只需要确保一个线程被加载进入就绪队列时，可以按照指定的优先级规则按序插入即可。  \n\n1. 确认什么时候线程会被加入就绪队列\n2. 需要一个优先级规则来指定线程加入就绪队列的办法。\n\n**数据结构**\n\n在进行这个部分的代码编写之前我们需要先去了解下pintos的底层的数据结构的设计。在 `lib/kernel/` 中，找到了pintos有关队列的数据结构的实现。\n\n```C\n/* List element. */\nstruct list_elem\n  {\n    struct list_elem *prev;     /* Previous list element. */\n    struct list_elem *next;     /* Next list element. */\n  };\n/* List. */\nstruct list\n  {\n    struct list_elem head;      /* List head. */\n    struct list_elem tail;      /* List tail. */\n  };\n```\n\n可以看到这是一个比较常规的实现，节点结构以及存有头尾的节点。然后在阅读了部分它所提供的功能函数以后，发现了 `list_insert_ordere(...)` 这一函数用于按照规则往队列中有序添加元素。如此一来我们只需要将原算法中的简单推入改为有序插入就行了。\n\n**算法&实现**\n\n编写插入排列规则。完成目标2。\n\n```C\n// 自定义优先级判定规则\nbool thread_cmp_priority(const struct list_elem *a, const struct list_elem *b, void *aux UNUSED)\n{\n  return list_entry(a, struct thread, elem)->priority > list_entry(b, struct thread, elem)->priority;\n}\n```\n\n确认什么时候线程会被加入就绪队列。并将其中旧算法替换，完成目标1。\n在函数 `thread_yield()`、`thread_init()`、`thread_unblock()`中。\n\n```C\n// // 无优先级的插入\n// list_push_back(&ready_list, &t->elem);\n// 优先级的插入\nlist_push_back (&ready_list, &t->elem);\n```\n\n## <font color=\'lightblue\'>第二部分</font>\n\n>实现线程的优先级调度，涉及到众多优先级变化情况与其对应的应对策略。\n\n### <font color=\'orange\' face=\"consolas\">priority-fifo\\preemt</font>\n\n>线程优先级发生变化后需要立即重新考虑所有线程的运行顺序，重新安排运行顺序。在该测试点中，测试点的要求输出要求我们在面对线程的优先级变化时，及时调整线程运行顺序。同时应当考虑新加入线程优先级高于当前线程而发生的抢占情况。\n\n**思路&Rational**  \n\n1. 在当前线程的优先级发生变化时，重新将其置入优先级就绪队列。\n2. 在新加入线程优先级高于当前线程时，重新将其置入优先级就绪队列。\n\n**数据结构**\n\n无。\n\n**算法&实现**\n\n更改 `thread_set_priority()` 函数，实现目标1。\n\n```C\n/* Sets the current thread\'s priority to NEW_PRIORITY. */\nvoid\nthread_set_priority (int new_priority)\n{\n  thread_current ()->priority = new_priority;\n  // 将线程重新移入就绪队列\n  thread_yield ();\n}\n```\n\n更改 `thread_create()` 函数，实现目标2。\n\n```C\ntid_t thread_create(const char *name, int priority,thread_func *function, void *aux){\n  ...\n  // 若创建的线程优先级比主线程高，将主线程放入就绪队列，重新分配执行顺序\n  if (thread_current()->priority < priority)\n    thread_yield();\n  ...\n}\n```\n\n### <font color=\'orange\' face=\"consolas\">priority-donate-one\\multiple\\multiple2\\nest\\sema\\lower\\preemt</font>\n\n>优先级捐赠的各种情况测试，这可能是整个 project 2 中最复杂的部分。\n\n**思路&Rational**  \n\n在仔细阅读了各个测试用例的源代码以及要求输出内容以后，总结了以下实现要点。\n\n1.  在一个线程获取一个锁的时候，如果拥有这个锁的线程优先级比自己低就提高它的优先级，并且如果这个锁还被别的锁锁着， 将会递归地捐赠优先级， 然后在这个线程释放掉这个锁之后恢复未捐赠逻辑下的优先级。( one )\n2.  如果一个线程被多个线程捐赠， 维持当前优先级为捐赠优先级中的最大值（ acquire 和 release 之时），需要优先级捐赠列表与保存最大优先级的变量。（ multiple、multiple2 ）\n3.  在对一个线程进行优先级设置的时候， 如果这个线程处于被捐赠状态， 则对 original_priority 进行设置， 然后如果设置的优先级大于当前优先级， 则改变当前优先级， 否则在捐赠状态取消的时候恢复original_priority。（lower）\n4.  在释放锁对一个锁优先级有改变的时候应考虑其余被捐赠优先级和当前优先级。\n5.  释放锁的时候若优先级改变则可以发生抢占。\n6.  需要经由锁知道lock的所有者是谁。（nest）\n\n**数据结构**\n\n首先我们需要给线程 `thread` 加入持有锁列表，与当前等待的锁。来满足基本逻辑要求。\n\n```C\n// 占有的锁的列表\nstruct list locks;         \n// 等待的锁\nstruct lock *lock_waiting; \n```\n\n为实现目标3我们还应当加入 `original_priority` 来确保捐赠后的回弹正常。\n\n```C\n// 原始的优先级\nint base_priority;\n```\n\n为实现目标2、6等内容，锁的结构设计如下。\n\n```C\n/* Lock. */\nstruct lock\n{\n  // 持有线程\n  struct thread *holder;\n  // 二元信号量\n  struct semaphore semaphore;\n  // 锁单元——在线程的占有锁列表中，给线程传递最高捐赠优先级\n  struct list_elem elem;\n  // 捐赠的最大优先级\n  int max_priority;\n};\n```\n\n**算法&实现**\n捐赠的过程主要发生在 `lock_acquire(lock *lock)` 函数执行期间，因此算法改进的主体从该函数入手。从持有锁前的优先级捐赠与持有锁后的锁与线程的相关参数变化入手。\n\n```C\nvoid lock_acquire(struct lock *lock)\n{\n  ...\n  // 若锁的持有者不为空\n  if (lock->holder != NULL && !thread_mlfqs)\n  {\n    current_thread->lock_waiting = lock;\n    l = lock;\n    // 递归地实现优先级捐赠\n    // 判断该锁的优先级的捐赠情况\n    while (l && current_thread->priority > l->max_priority)\n    {\n      // 更新锁受捐赠最大优先级\n      l->max_priority = current_thread->priority;\n      // 捐赠优先级\n      thread_donate_priority(l->holder);\n      // 判断锁的持有者正在等待的锁的情况\n      // 因为锁的持有者的优先级收到了捐赠发生变化\n      // 那么锁持有者所等待的锁也应判断是否受到优先级捐赠\n      l = l->holder->lock_waiting;\n    }\n  }\n\n  // 成功获取到锁\n  sema_down(&lock->semaphore);\n  // 禁止被中断包裹\n  old_level = intr_disable();\n\n  // 获取当前进程\n  current_thread = thread_current();\n  if (!thread_mlfqs)\n  {\n    // 正在等待的锁置空\n    current_thread->lock_waiting = NULL;\n    // 锁最大优先级初始化为当前进程优先级\n    lock->max_priority = current_thread->priority;\n    // 设置持有该锁\n    thread_hold_the_lock(lock);\n  }\n  // 锁的持有者为当前线程\n  lock->holder = current_thread;\n  // lock->holder = thread_current();\n\n  intr_set_level(old_level);\n}\n```\n\n这里将捐赠优先级的过程与持有锁后的参数初始化封装为了两个函数。`thread_donate_priority(lock.holder)` 与 `thread_hold_the_lock(lock)`。\n\n```C\nvoid thread_donate_priority(struct thread *t)\n{\n  ...\n  // 更新t线程（受捐赠）优先级\n  thread_update_priority(t);\n  // 重新加入优先级就绪队列\n  if (t->status == THREAD_READY)\n  {\n    list_remove(&t->elem);\n    list_insert_ordered(&ready_list, &t->elem, thread_cmp_priority, NULL);\n  }\n  ...\n}\n```\n\n```C\nvoid thread_hold_the_lock(struct lock *lock)\n{\n  // 将当前锁加入线程占有锁列表\n  list_insert_ordered(&thread_current()->locks, &lock->elem, lock_cmp_priority, NULL);\n\n  // 若锁最大优先级大于当前进程优先级，即优先级要发生改变的情况\n  if (lock->max_priority > thread_current()->priority)\n  {\n    // 重置当前进程优先级，重新调度就绪队列\n    thread_current()->priority = lock->max_priority;\n    thread_yield();\n  }\n}\n```\n\n这里又再次把更新线程受捐赠优先级独立封装为一个函数 `thread_update_priority(thread)`。\n\n```C\n// 当释放掉一个锁的时候，当前线程的优先级可能发生变化，更广泛地来说，在持有的锁发生变化时， 用于更新线程的优先级变化\nvoid thread_update_priority(struct thread *t)\n{\n  // 初始化最终优先级为初始优先级\n  int final_priority = t->base_priority;\n  int lock_priority;\n\n  // 若当前线程持有的锁不为空\n  if (!list_empty(&t->locks))\n  {\n    // 找到最高的捐赠优先级\n    list_sort(&t->locks, lock_cmp_priority, NULL);\n    lock_priority = list_entry(list_front(&t->locks), struct lock, elem)->max_priority;\n    \n    // 若锁的最高捐赠优先级较大\n    if (lock_priority > final_priority)\n      // 则受捐赠，最终优先级变化，被较大者取代\n      final_priority = lock_priority;\n  }\n\n  // 若为空，代表将不再受优先级捐赠，变回初始化优先级\n  t->priority = final_priority;\n}\n```\n\n在考虑完了捐赠过程发生的主要情况后，同样需要考虑捐赠结束后的处理过程。这里各部分逻辑主要发生在函数 `thread_remove_lock(lock)` 前后。\n\n```C\nvoid thread_remove_lock(struct lock *lock)\n{\n  enum intr_level old_level = intr_disable();\n\n  // 将持有锁列表中的目标锁移除\n  list_remove(&lock->elem);\n  // 持有锁发生变化，更新当前线程优先级\n  thread_update_priority(thread_current());\n\n  intr_set_level(old_level);\n}\n```\n\n同时还需要考虑强行修改优先级后的捐赠变化情况，即 `thread_update_priority(thread)` 发动的可能性。同样对其做一定修改。\n\n```C\nvoid thread_set_priority(int new_priority)\n{\n  // 将原优先级保留  \n  int old_priority = current_thread->priority;\n  // 基础优先级更新为新优先级\n  current_thread->base_priority = new_priority;\n\n  // 如果该线程不占有锁，或新优先级大于旧优先级，优先级发生重置的情况\n  if (list_empty(&current_thread->locks) || new_priority > old_priority)\n  {\n    // 直接设置优先级为新优先级\n    current_thread->priority = new_priority;\n    \n    // 重置优先级了以后直接返回就绪队列重新分配执行顺序\n    thread_yield();\n  }\n}\n```\n\n至此主要逻辑都已经处理完毕，剩下的参数初始化以及锁排列规则一类累赘重复的内容不再赘述。\n\n### <font color=\'orange\' face=\"consolas\">priority-sema</font>\n\n>将信号量的等待队列实现为优先级队列。比较简单的内容。不过需要深入了解一下 pintos 中的信号量的数据结构与相关函数。\n\n**思路&Rational**  \n\n了解信号量的数据结构以后，类似于处理就绪队列的优先级方式同样对其内部队列做处理。\n\n**数据结构**\n\n```C\n// 信号量结构\nstruct semaphore\n{\n  unsigned value;\n  // 阻塞队列\n  struct list waiters;\n};\n```\n\n可以看到其内部确实有个阻塞队列，问题就解决了。\n\n**算法&实现**\n\n修改其加入与取出队列涉及到的函数 `sema_up(*sema)` 与 `sema_down(*sema)`。\n\n```C\nvoid sema_up(struct semaphore *sema)\n{\n  ...\n  // 将优先级最高的线程从阻塞队列中取出\n  if (!list_empty(&sema->waiters))\n  {\n    // 按优先级规则排序\n    list_sort(&sema->waiters, thread_cmp_priority, NULL);\n    thread_unblock(list_entry(list_pop_front(&sema->waiters),\n                              struct thread, elem));\n  }\n  // 释放信号量\n  sema->value++;\n  // 将当前线程加入就绪队列\n  thread_yield();\n  ...\n}\n```\n\n```C\nvoid sema_down(struct semaphore *sema)\n{\n  // 信号量归0，执行wait\n  while (sema->value == 0)\n  {\n    // 类似于之前的指定规则优先级实现\n    list_insert_ordered(&sema->waiters, &thread_current()->elem, thread_cmp_priority, NULL);\n    thread_block();\n  }\n  // 信号量自减，资源被占用\n  sema->value--;\n}\n```\n\n### <font color=\'orange\' face=\"consolas\">priority-condvar</font> \n\n>将condition的waiters队列实现为优先级队列。实现方案几乎与之前无异。略写。\n\n**思路&Rational**  \n\n将condition的waiters队列仿照之前实现为优先级队列。\n\n**数据结构**\n\n无。\n\n**算法&实现**\n\n```C\nvoid cond_signal(struct condition *cond, struct lock *lock UNUSED)\n{\n  ...\n  if (!list_empty(&cond->waiters))\n  {\n    // 优先级调度唤醒\n    list_sort(&cond->waiters, cond_sema_cmp_priority, NULL);\n    // 释放\n    sema_up(&list_entry(list_pop_front(&cond->waiters), struct semaphore_elem, elem)->semaphore);\n  }\n}\n```\n\n比较规则。\n\n```C\nbool cond_sema_cmp_priority(const struct list_elem *a, const struct list_elem *b, void *aux UNUSED)\n{\n  struct semaphore_elem *sa = list_entry(a, struct semaphore_elem, elem);\n  struct semaphore_elem *sb = list_entry(b, struct semaphore_elem, elem);\n  return list_entry(list_front(&sa->semaphore.waiters), struct thread, elem)->priority > list_entry(list_front(&sb->semaphore.waiters), struct thread, elem)->priority;\n}\n```\n\n## <font color=\'lightblue\'>第三部分</font>\n\n>实现多级反馈调度。其实是一个实现参数动态变化的过程。通过公式计算来计算出线程当前的优先级，系统调度的时候会从高优先级队列开始选择线程执行，这里线程的优先级随着操作系统的运转数据而动态改变。\n\n### <font color=\'orange\' face=\"consolas\">mlfqs-load-1/60/avg mlfqs-recent-1 mlfqs-fair-2/20 mlfqs-nice-2/10 mlfqs-block</font>\n\n**思路&Rational**  \n\n1. 该算法的优先级是动态变化的，主要动态修改Niceness, Priority, recent_cpu, load_avg四大变量\n2. Priority的计算公式为：priority= PRI_MAX - (recent_cpu/ 4) - (nice*2)，每四个clock tick对所有线程更新一次\n3. recent_cpu的计算公式为recent_cpu= (2*load_avg)/(2*load_avg+ 1) *recent_cpu+nice，当timer_ticks () % TIMER_FREQ == 0时对所有线程更新，每个tick对当前线程的recent_cpu加1。\n4. load_avg的计算公式为load_avg= (59/60)*load_avg+ (1/60)*ready_threads，当timer_ticks () % TIMER_FREQ == 0时对所有线程更新。  \n   部署浮点运算部分略去。\n\n**数据结构**\n\n即为 `thread` 增加 Niceness 和 recent_cpu 两个变量用于算法运算。\n\n```C\n// 多级反馈调度参数，动态修改的变量\nint nice;\nfixed_point_t recent_cpu;\n```\n\n**算法&实现**\n\n由于要动态持续更新，因此需要将更新的函数置于前面提到的 `timer_interrupt()` 中。\n\n```C\nstatic void timer_interrupt(struct intr_frame *args UNUSED)\n{\n  ...\n  if (thread_mlfqs)\n  {\n    thread_mlfqs_increase_recent_cpu_by_one();\n    // 当timer_ticks () % TIMER_FREQ == 0时对所有线程更新\n    if (ticks % TIMER_FREQ == 0)\n      thread_mlfqs_update_load_avg_and_recent_cpu();\n    // 每4秒更新一次priority\n    else if (ticks % 4 == 0)\n      thread_mlfqs_update_priority(thread_current());\n  }\n  ...\n}\n```\n\n其中 recent_cpu 的自增函数、recent_cpu 与 load_avg 的计算函数、priority 的计算函数被独立封装。\n\n```C\n// recent_cpu 的自增函数\nvoid thread_mlfqs_increase_recent_cpu_by_one(void)\n{\n  ...\n  struct thread *current_thread = thread_current();\n  if (current_thread != idle_thread)\n    // 每个tick对当前线程的recent_cpu加1\n    current_thread->recent_cpu = fix_add(current_thread->recent_cpu, fix_int(1));\n}\n```\n\n```C\n// recent_cpu 与 load_avg 的计算函数\nvoid thread_mlfqs_update_load_avg_and_recent_cpu(void)\n{\n  ...\n  // 对每个就绪线程\n  // load_avg= (59/60)*load_avg+ (1/60)*ready_threads\n  size_t ready_threads = list_size(&ready_list);\n  if (thread_current() != idle_thread)\n    ready_threads++;\n  load_avg = fix_add(fix_unscale(fix_scale(load_avg, 59), 60), fix_unscale(fix_int(ready_threads), 60));\n\n  struct thread *t;\n  struct list_elem *e = list_begin(&all_list);\n  // 对每个线程更新\n  // recent_cpu= (2*load_avg)/(2*load_avg+ 1) *recent_cpu+nice\n  for (; e != list_end(&all_list); e = list_next(e))\n  {\n    t = list_entry(e, struct thread, allelem);\n    if (t != idle_thread)\n    {\n      t->recent_cpu = fix_add(fix_mul(fix_div(fix_scale(load_avg, 2), fix_add(fix_scale(load_avg, 2), fix_int(1))), t->recent_cpu), fix_int(t->nice));\n      // 计算并更新 priority\n      thread_mlfqs_update_priority(t);\n    }\n  }\n}\n```\n\n```C\n// priority 的计算函数\nvoid thread_mlfqs_update_priority(struct thread *t)\n{\n  ...\n  // priority= PRI_MAX - (recent_cpu/ 4) - (nice*2)\n  t->priority = fix_trunc(fix_sub(fix_sub(fix_int(PRI_MAX), fix_unscale(t->recent_cpu, 4)), fix_int(2 * t->nice)));\n  // 溢出检测\n  t->priority = t->priority < PRI_MIN ? PRI_MIN : t->priority;\n  t->priority = t->priority > PRI_MAX ? PRI_MAX : t->priority;\n}\n```\n\n## <font color=\'lightblue\'>关于 Synchronization</font>\n\n>在本次课程设计中，一个主要内容就是线程的同步。\n\n其主要内容集中在第二第三部分，其中对于多进程之间的优先级调度做了许多具体且深入的实现。比如捐赠部分可以说是 threads 线程部分在本次课设中逻辑最复杂的部分，其解决了线程占用资源后线程之间优先级与实际运行线程优先级的冲突问题，实现线程同步。  \n同样的对 pintos 中的信号量与\'锁\'的数据结构与功能函数的深入了解，也更好地从底层深入了解了线程之间同步的实现。  \n至于大多数时候为什么要采取某种策略来实现线程同步，已经在前面的文档中给出了比较详细的解释，这里不再重复。\n\n## <font color=\'lightblue\'>关于 Shell</font>\n\n在本次Shell的设计中，主要参考了博客：https://blog.csdn.net/qq_43326014/article/details/107215174  \n下面给出Shell程序的运行流程。  \n\n>进入 `main()`  -->  \n>执行 `init_shell()`，完成 Shell 的初始化 -->  \n>执行 `set_prompt()`，设置用户提示 -->  \n>获取用户输入，并将其分解为 token -->  \n>执行 `analysis_command()`，分析用户输入的token -->  \n>执行 `lookup(tokens_get_token(tokens, 0))`，寻找目标指令 -->  \n>执行 `do_command()`，执行指令 -->  \n>清理 token 内存  \n\n在分析完了程序的运行流程后，就可以开始设计具体的命令功能。\n经过学习那篇博客，实现了如下功能。\n\n1. 编写一个 C 语言程序作为 Linux 内核的 shell 命令行解释程序，所执行的结果需和系统命令行方式保持一致。\n2. 后台运行功能。即用户可以使用 ”&” 作为一个命令结束，以启动下一个命令。\n3. I/O 重定向功能。即用户可以使用 ”<” 和 ”>” 符号改变程序/文件的输入和输出。\n4. 管道功能。即支持以 “|” 进行进程间通信操作。\n5. 退出功能。输入 “exit” 命令或者 Ctrl + D 退出。\n6. 查阅历史记录的功能。可以查看历史命令。\n7. 目录检索功能。即文件不存在，继续打印提示符。\n8. 一定的错误输入处理。例如：多于空格的出现，输入命令不存在，空输入等等。\n\n不过本次课设我的精力主要集中在了 pintos 上，因此 shell 部分做的较为粗糙。\n\n## <font color=\'lightblue\'>额外内容</font>\n\n>对专业知识基本概念、基本理论和典型方法的理解。\n\n这是一门讲解操作系统的主要构成以及各功能的课程。  \n操作系统(Operating System, OS)：是指控制和管理整个计算机系统的硬件和软件资源，并合理地组织调度计算机的工作和资源分配，以提供给用户和其他软件方便的接口和环境的软件集合。其基本特征为并发、共享、虚拟、异步。  \n其基础理论主要涉及进程与线程，资源死锁，内存管理，进程调度，信号量，虚存实存等内容，也就是本学期课程中学习的主要内容。  \n典型方法包括线程调度算法，银行家算法等，这些算法的提出都是因为系统在某种情境下存在着某些风险或是某些问题（可被优化），并针对问题提出解决，在解决问题前应当详细地对问题进行分析，这也是我学习完操作系统后在解决问题层面的感悟。\n\n>怎么建立模型。\n\n模型的建立应当取决于实际问题信息的提取，在对实际问题的数学模式进行了一定程度的分析了以后可以考虑解决问题需要的逻辑结构，进而考虑为实现这个逻辑结构需要的数据结构，进而完成模型的建立。类似于课程设计中为解决线程捐赠的问题先考虑问题的关键，在进而建立便于解决问题的模型。\n\n>如何利用基本原理解决复杂问题。\n\n基本原理是最基本的工具，我认为在面对复杂问题是不应当直接与其与基本原理相关连，而是将其细化细分成由一个个基本原理单元组成的问题，这一过程可以帮助确认问题是否能从原理层面解决，也可以更容易地去入手解决问题。正如软件设计模式中，面对大型模块常用的方法也是将其细化到底层接口。\n\n>具有实验方案设计的能力。\n\n在阅读博客的时候领悟了一些。\n\n>如何对环境和社会的可持续发展。\n\n该系统完成的内容只是操作系统的基本功能，尚有十分大的拓展空间，希望我自己以后有机会能够再次阅读这份源代码，以此获得对操作系统更深刻的理解。', '2021-07-27 11:28:29', 0);

-- ----------------------------
-- Table structure for m_site
-- ----------------------------
DROP TABLE IF EXISTS `m_site`;
CREATE TABLE `m_site`  (
  `id` bigint(10) NOT NULL AUTO_INCREMENT,
  `avatar` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NULL DEFAULT NULL,
  `slogan` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NULL DEFAULT NULL,
  `name` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NULL DEFAULT NULL,
  `notice` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NULL DEFAULT NULL,
  `description` longtext CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NULL,
  PRIMARY KEY (`id`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 2 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_0900_ai_ci ROW_FORMAT = Dynamic;

-- ----------------------------
-- Records of m_site
-- ----------------------------
INSERT INTO `m_site` VALUES (1, 'https://s2.ax1x.com/2020/01/17/1SCadg.png', '撸起袖子加油干', '蒋荷包蛋', '目前为 Demo 版本。', '一个涉猎广泛的后端工程师');

-- ----------------------------
-- Table structure for m_user
-- ----------------------------
DROP TABLE IF EXISTS `m_user`;
CREATE TABLE `m_user`  (
  `id` bigint(20) NOT NULL AUTO_INCREMENT,
  `username` varchar(64) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL,
  `avatar` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL,
  `email` varchar(64) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL,
  `password` varchar(64) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL,
  `status` int(5) NOT NULL DEFAULT 0,
  `created` datetime NULL DEFAULT NULL,
  `last_login` datetime NULL DEFAULT NULL,
  PRIMARY KEY (`id`) USING BTREE,
  INDEX `UK_USERNAME`(`username`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 4 CHARACTER SET = utf8 COLLATE = utf8_general_ci ROW_FORMAT = Dynamic;

-- ----------------------------
-- Records of m_user
-- ----------------------------
INSERT INTO `m_user` VALUES (3, 'root', NULL, '123@qq.com', 'd4743b6ab72f17efad97f445f4bbbe55', 0, NULL, NULL);

SET FOREIGN_KEY_CHECKS = 1;
